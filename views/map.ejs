<!-- map -->
<div id="mapDiv" class="sideForm" style="display: none"></div>

<script>
  let db;
  let mapDiv = document.getElementById("mapDiv");
  let mapCache = {
    zoneFloorName: "",
    mapTileStates: {},
  };

  function initiateDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open("restoria", 1);

      request.onerror = (event) => {
        reject(`Database error: ${event.target.error}`);
      };

      request.onupgradeneeded = function (event) {
        db = event.target.result;
        let objectStore = db.createObjectStore("zoneFloorMaps", {
          keyPath: "zoneFloorName",
        });
        objectStore.createIndex("zoneFloorName", "zoneFloorName", {
          unique: true,
        });
      };

      request.onsuccess = (event) => {
        db = event.target.result;

        // Handle database connection errors
        db.onerror = (event) => {
          console.error("Database error:", event.target.error);
        };

        // Handle connection closing
        window.addEventListener("beforeunload", () => {
          db.close();
        });

        resolve(db);
      };
    });
  }
  initiateDB();

  async function loadMapByName(zoneFloorName) {
    if (!db) {
      console.error("Database not initialized.");
      return;
    }

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(["zoneFloorMaps"], "readonly");
      const objectStore = transaction.objectStore("zoneFloorMaps");
      const getRequest = objectStore.get(zoneFloorName);

      getRequest.onsuccess = function (event) {
        let zoneFloorMap = event.target.result;
        if (
          !zoneFloorMap ||
          !zoneFloorMap.zoneFloorName ||
          !zoneFloorMap.mapTileStates
        ) {
          zoneFloorMap = {
            zoneFloorName: zoneFloorName,
            mapTileStates: {},
          };
        }
        console.log(
          "loadMapByName putting zoneFloorMap to cache:",
          zoneFloorMap
        );
        mapCache = zoneFloorMap;
        resolve(mapCache);
      };

      getRequest.onerror = function (event) {
        console.error("Error loading map:", event.target.error);
        mapCache = {
          zoneFloorName: zoneFloorName,
          mapTileStates: {},
        };
        reject(event.target.error);
      };
    });
  }

  let lastMapSaveTime = 0;

  async function saveMap() {
    const now = Date.now();
    console.log("saveMap called at:", now, "lastMapSaveTime:", lastMapSaveTime);
    if (now - lastMapSaveTime < 5000) {
      console.log("saveMap debounced, skipping save.");
      return;
    }
    lastMapSaveTime = now;

    if (!db) {
      console.error("Database not initialized.");
      return;
    }

    console.log("saveMap trying to save to db:", db);
    console.log(
      "saveMap trying to save mapCache for zoneFloorName:",
      mapCache.zoneFloorName
    );

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(["zoneFloorMaps"], "readwrite");
      const objectStore = transaction.objectStore("zoneFloorMaps");
      const putRequest = objectStore.put(mapCache);

      putRequest.onsuccess = function (event) {
        console.log("Map saved successfully to objectStore:", objectStore);
        resolve();
      };

      putRequest.onerror = function (event) {
        console.error("Error saving map:", event.target.error);
        reject(event.target.error);
      };
    });
  }

  function putMapTileStateInCache(mapTileState) {
    if (!mapTileState || !mapTileState.mapCoords) {
      console.error("Invalid mapTileState:", mapTileState);
      return;
    }

    mapCache.mapTileStates[mapTileState.mapCoords.join(",")] = mapTileState;
  }

  function populateMap(userMapCoords) {
    if (!userMapCoords) {
      console.error("Invalid mapCoords:", userMapCoords);
      return;
    }

    mapDiv.innerHTML = ""; // Clear previous map

    // display mapCache.zoneFloorName centered above the map
    let zoneFloorNameDiv = document.createElement("div");
    zoneFloorNameDiv.classList.add("zone-floor-name");
    zoneFloorNameDiv.innerText = mapCache.zoneFloorName || "Unknown Zone Name";
    mapDiv.appendChild(zoneFloorNameDiv);

    // with userMapCoords in the center, display map tiles
    let mapRadius = 8;
    for (let i = -mapRadius; i <= mapRadius; i++) {
      for (let j = -mapRadius; j <= mapRadius; j++) {
        let mapTileCoords = [userMapCoords[0] + i, userMapCoords[1] + j];
        let mapTileState = mapCache.mapTileStates[mapTileCoords.join(",")];
        if (!mapTileState) {
          mapTileState = {
            mapCoords: mapTileCoords,
            mapTile: {
              character: "",
              color: "black",
              wallColor: "black",
            },
            walls: {
              north: "open",
              east: "open",
              south: "open",
              west: "open",
            },
          };
        }

        let mapTile = document.createElement("div");
        mapTile.style.width = "2rem";
        mapTile.style.height = "2rem";
        mapTile.style.display = "inline-block";
        mapTile.style.color = mapTileState.mapTile.color;
        mapTile.innerText = mapTileState.mapTile.character;
        // set mapTile borders based on mapTileState.walls values being "open" (no border), "wall" (single line), or "closed" (double line)
        const wallStyles = {
          open: "none",
          wall: `1px solid ${mapTileState.mapTile.wallColor}`,
          closed: `2px solid ${mapTileState.mapTile.wallColor}`,
        };
        mapTile.style.borderTop = wallStyles[mapTileState.walls.north];
        mapTile.style.borderRight = wallStyles[mapTileState.walls.east];
        mapTile.style.borderBottom = wallStyles[mapTileState.walls.south];
        mapTile.style.borderLeft = wallStyles[mapTileState.walls.west];
        mapDiv.appendChild(mapTile);
      }
      mapDiv.appendChild(document.createElement("br"));
    }
  }

  socket.on("mapRequest", async function (zoneFloorName, mapTileState) {
    console.log("mapRequest received:", zoneFloorName, mapTileState);
    if (!zoneFloorName || !mapTileState) {
      console.error("Invalid mapTileState data:", mapTileState);
      return;
    }

    if (mapCache.zoneFloorName !== zoneFloorName) {
      console.log(
        "Received a mapTileState from a different zone, loading new map:",
        zoneFloorName
      );
      if (mapCache.zoneFloorName) {
        await saveMap();
      }
      await loadMapByName(zoneFloorName);
      console.log("mapCache after loadMapByName:", mapCache);
    }
    putMapTileStateInCache(mapTileState)
    console.log("mapCache after putMapTileStateInCache:", mapCache);
    saveMap()
    populateMap(mapTileState.mapCoords);
    resetActiveSidebarElementTo(mapDiv);
  });
</script>
